{
  "query": "habit tracking and streak calculation",
  "collection": "both",
  "top_k": 5,
  "results": [
    {
      "id": "lib\\screens\\stats_screen.dart::chunk_10",
      "file": "lib\\screens\\stats_screen.dart",
      "chunk": "    int totalExpected = 0;\n\n    // Calcular d\u00edas activos y total de completados\n    for (int i = 0; i < now.day; i++) {\n      final day = monthStart.add(Duration(days: i));\n      final dayStr = day.toDateString();\n\n      int dayCompleted = 0;\n      int dayTotal = 0;\n\n      for (final habit in habits) {\n        if (habit.frequency.contains(day.weekday)) {\n          dayTotal++;\n          if (habit.completions[dayStr] ?? false) {\n            dayCompleted++;\n          }\n        }\n      }\n\n      if (dayCompleted > 0) activeDays++;\n      totalCompleted += dayCompleted;\n      totalExpected += dayTotal;\n    }\n\n    // Calcular mejor racha\n    for (final habit in habits) {\n      final streak = _calculateCurrentStreak(habit);\n      if (streak > bestStreak) bestStreak = streak;\n    }\n\n    final averageCompletion = totalExpected > 0 ? ((totalCompleted / totalExpected) * 100).round() : 0;\n\n    return {\n      'activeDays': activeDays,\n      'bestStreak': bestStreak,\n      'averageCompletion': averageCompletion,\n    };\n  }\n\n  Widget _buildWeeklyHabitsList(List<Map<String, dynamic>> weekHabits) {\n    if (weekHabits.isEmpty) {\n      return Card(\n        child: Padding(\n          padding: const EdgeInsets.all(DesignConstants.cardPadding),\n          child: Center(\n            child: Text(AppLocalizations.of(context)!.noHabitsToShow),\n          ),\n        ),\n      );\n    }\n\n    return Card(\n      child: Padding(\n        padding: const EdgeInsets.all(DesignConstants.cardPadding),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text(\n              AppLocalizations.of(context)!.weekHabits,\n              style: Theme.of(context).textTheme.titleLarge?.copyWith(\n                fontWeight: FontWeight.bold,\n              ),\n            ),\n            const SizedBox(height: 16),\n            ...weekHabits.map((habitData) {\n              final habit = habitData['habit'] as Habit;\n              final completedDays = habitData['completedDays'] as int;\n              final scheduledDays = habitData['scheduledDays'] as int;\n              final percentage = habitData['percentage'] as int;\n\n              return Padding(\n                padding: const EdgeInsets.symmetric(vertical: 8),\n                child: Row(\n                  children: [\n                    Container(\n                      width: 40,\n                      height: 40,\n                      decoration: BoxDecoration(\n                        color: Color(habit.color).withValues(alpha: 0.2),\n                        shape: BoxShape.circle,\n                      ),\n                      child: Icon(\n                        habit.icon,\n                        color: Color(habit.color),\n                        size: DesignConstants.habitIconSize,\n                      ),\n                    ),\n                    const SizedBox(width: 12),\n                    Expanded(\n                      child: Column(\n                        crossAxisAlignment: CrossAxisAlignment.start,\n                        children: [\n                          Text(\n                            habit.name,\n                            style: const TextStyle(\n                              fontWeight: FontWeight.w600,\n                              fontSize: 16,\n                            ),\n                          ),\n                          const SizedBox(height: 4),\n                          Text(\n                            AppLocalizations.of(context)!.weekProgress(completedDays, scheduledDays),\n                            style: TextStyle(\n                              color: Colors.grey[600],\n                              fontSize: 14,\n                            ),\n                          ),",
      "score": 0.5933880805969238,
      "metadata": {
        "chunk_index": 10,
        "file": "lib\\screens\\stats_screen.dart",
        "language": "dart",
        "type": "code",
        "indexed_at": "2025-10-08T13:43:30.358359"
      },
      "collection": "code"
    },
    {
      "id": "lib\\screens\\stats_screen.dart::chunk_8",
      "file": "lib\\screens\\stats_screen.dart",
      "chunk": "        final currentDay = weekStart.add(Duration(days: day));\n        if (currentDay.month != now.month || currentDay.isAfter(weekEnd)) continue;\n\n        final dayStr = currentDay.toDateString();\n\n        for (final habit in habits) {\n          if (habit.frequency.contains(currentDay.weekday)) {\n            total++;\n            if (habit.completions[dayStr] ?? false) {\n              completed++;\n            }\n          }\n        }\n      }\n\n      final percentage = total > 0 ? (completed / total) * 100 : 0.0;\n      spots.add(FlSpot(week.toDouble(), percentage.toDouble()));\n    }\n\n    return spots;\n  }\n\n  List<double> _getStreakData(List<Habit> habits) {\n    return habits.map((habit) {\n      return _calculateCurrentStreak(habit).toDouble();\n    }).toList();\n  }\n\n  int _calculateCurrentStreak(Habit habit) {\n    final now = DateTime.now();\n    int streak = 0;\n\n    for (int i = 0; i < 30; i++) {\n      final day = now.subtract(Duration(days: i));\n      final dayStr = day.toDateString();\n\n      if (habit.frequency.contains(day.weekday)) {\n        if (habit.completions[dayStr] ?? false) {\n          streak++;\n        } else {\n          break;\n        }\n      }\n    }\n\n    return streak;\n  }\n\n  Widget _buildCalendarHeatmap(List<Habit> habits) {\n    final now = DateTime.now();\n    final monthStart = DateTime(now.year, now.month, 1);\n    final monthEnd = DateTime(now.year, now.month + 1, 0);\n    final daysInMonth = monthEnd.day;\n\n    final dayLabels = [\n      AppLocalizations.of(context)!.dayShortMon,\n      AppLocalizations.of(context)!.dayShortTue,\n      AppLocalizations.of(context)!.dayShortWed,\n      AppLocalizations.of(context)!.dayShortThu,\n      AppLocalizations.of(context)!.dayShortFri,\n      AppLocalizations.of(context)!.dayShortSat,\n      AppLocalizations.of(context)!.dayShortSun,\n    ];\n\n    return Column(\n      children: [\n        // Header con d\u00edas de la semana\n        Row(\n          children: dayLabels.map((day) =>\n            Expanded(\n              child: Center(\n                child: Text(\n                  day,\n                  style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 12),\n                ),\n              ),\n            ),\n          ).toList(),\n        ),\n        const SizedBox(height: 8),\n        // Grid del calendario\n        ...List.generate((daysInMonth / 7).ceil(), (weekIndex) {\n          return Padding(\n            padding: const EdgeInsets.symmetric(vertical: 2),\n            child: Row(\n              children: List.generate(7, (dayIndex) {\n                final dayNumber = weekIndex * 7 + dayIndex + 1 - (monthStart.weekday - 1);\n\n                if (dayNumber < 1 || dayNumber > daysInMonth) {\n                  return const Expanded(child: SizedBox(height: 32));\n                }\n\n                final day = DateTime(now.year, now.month, dayNumber);\n                final dayStr = day.toDateString();\n                final intensity = _getDayIntensity(habits, day, dayStr);",
      "score": 0.567744791507721,
      "metadata": {
        "type": "code",
        "language": "dart",
        "file": "lib\\screens\\stats_screen.dart",
        "indexed_at": "2025-10-08T13:43:30.238740",
        "chunk_index": 8
      },
      "collection": "code"
    },
    {
      "id": "lib\\providers\\gamification_provider.dart::chunk_3",
      "file": "lib\\providers\\gamification_provider.dart",
      "chunk": "  int _calculateTotalCompletions() {\n    // This would be calculated from actual habit data\n    return 0; // Placeholder\n  }\n\n  double _calculateAverageCompletion() {\n    // This would be calculated from actual habit data\n    return 0.0; // Placeholder\n  }\n\n  int _calculateLongestStreakFromHabits(List<Habit> habits) {\n    int longestStreak = 0;\n    for (final habit in habits) {\n      final streak = _calculateHabitStreak(habit);\n      if (streak > longestStreak) {\n        longestStreak = streak;\n      }\n    }\n    return longestStreak;\n  }\n\n  int _calculateTotalCompletionsFromHabits(List<Habit> habits) {\n    int total = 0;\n    for (final habit in habits) {\n      total += habit.completions.values.where((completed) => completed).length;\n    }\n    return total;\n  }\n\n  int _calculateHabitStreak(Habit habit) {\n    // Usar el m\u00e9todo mejorado del modelo Habit\n    return habit.calculateStreak();\n  }\n\n  bool _checkConsistencyAchievement(List<Habit> habits, Achievement achievement) {\n    if (achievement.id == 'perfect_week') {\n      // Check if all habits were completed for the last 7 days\n      final now = DateTime.now();\n      for (int i = 0; i < 7; i++) {\n        final day = now.subtract(Duration(days: i));\n        final dayStr = day.toDateString();\n\n        for (final habit in habits) {\n          if (habit.frequency.contains(day.weekday)) {\n            if (!(habit.completions[dayStr] ?? false)) {\n              return false;\n            }\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  void addPoints(int points) {\n    _totalPoints += points;\n    final newLevel = GameStats.calculateLevel(_totalPoints);\n    if (newLevel > _level) {\n      _level = newLevel;\n    }\n    _saveProgress();\n    notifyListeners();\n  }\n\n  void removePoints(int points) {\n    _totalPoints = (_totalPoints - points).clamp(0, _totalPoints);\n    final newLevel = GameStats.calculateLevel(_totalPoints);\n    if (newLevel < _level) {\n      _level = newLevel;\n    }\n    _saveProgress();\n    notifyListeners();\n  }\n\n  double getLevelProgress() {\n    final currentLevelPoints = GameStats.pointsForLevel(_level);\n    final nextLevelPoints = GameStats.pointsForLevel(_level + 1);\n    final levelRange = nextLevelPoints - currentLevelPoints;\n    final currentProgress = _totalPoints - currentLevelPoints;\n\n    if (levelRange <= 0) return 1.0;",
      "score": 0.536465048789978,
      "metadata": {
        "type": "code",
        "file": "lib\\providers\\gamification_provider.dart",
        "language": "dart",
        "indexed_at": "2025-10-08T13:43:24.749630",
        "chunk_index": 3
      },
      "collection": "code"
    },
    {
      "id": "lib\\widgets\\stats_overview.dart::chunk_4",
      "file": "lib\\widgets\\stats_overview.dart",
      "chunk": "        if (habit.frequency.contains(day.weekday)) {\n          totalScheduled++;\n          if (habit.completions[dayStr] ?? false) {\n            totalCompleted++;\n          }\n        }\n      }\n    }\n\n    final percentage = totalScheduled > 0 ? (totalCompleted / totalScheduled) * 100 : 0.0;\n    return {\n      'completed': totalCompleted,\n      'total': totalScheduled,\n      'percentage': percentage,\n    };\n  }\n\n  Map<String, dynamic> _getMonthlyProgress(List<Habit> habits) {\n    final now = DateTime.now();\n    final monthStart = DateTime(now.year, now.month, 1);\n    final daysInMonth = DateTime(now.year, now.month + 1, 0).day;\n\n    int totalCompleted = 0;\n    int totalScheduled = 0;\n\n    for (int i = 0; i < daysInMonth; i++) {\n      final day = monthStart.add(Duration(days: i));\n      if (day.isAfter(now)) break;\n\n      final dayStr = day.toDateString();\n\n      for (final habit in habits) {\n        if (habit.frequency.contains(day.weekday)) {\n          totalScheduled++;\n          if (habit.completions[dayStr] ?? false) {\n            totalCompleted++;\n          }\n        }\n      }\n    }\n\n    final percentage = totalScheduled > 0 ? (totalCompleted / totalScheduled) * 100 : 0.0;\n    return {\n      'completed': totalCompleted,\n      'total': totalScheduled,\n      'percentage': percentage,\n    };\n  }\n\n  // M\u00e9todos auxiliares mejorados\n  String _getTimeGreeting() {\n    final hour = DateTime.now().hour;\n    if (hour < 12) return AppLocalizations.of(context)!.goodMorning;\n    if (hour < 18) return AppLocalizations.of(context)!.goodAfternoon;\n    return AppLocalizations.of(context)!.goodEvening;\n  }\n\n  String _getTodayDateString() {\n    final now = DateTime.now();\n    final months = [\n      '', AppLocalizations.of(context)!.january, AppLocalizations.of(context)!.february, AppLocalizations.of(context)!.march, AppLocalizations.of(context)!.april, AppLocalizations.of(context)!.may, AppLocalizations.of(context)!.june,\n      AppLocalizations.of(context)!.july, AppLocalizations.of(context)!.august, AppLocalizations.of(context)!.september, AppLocalizations.of(context)!.october, AppLocalizations.of(context)!.november, AppLocalizations.of(context)!.december\n    ];\n    final days = ['', AppLocalizations.of(context)!.mondayFull, AppLocalizations.of(context)!.tuesdayFull, AppLocalizations.of(context)!.wednesdayFull, AppLocalizations.of(context)!.thursdayFull, AppLocalizations.of(context)!.fridayFull, AppLocalizations.of(context)!.saturdayFull, AppLocalizations.of(context)!.sundayFull];\n\n    return AppLocalizations.of(context)!.dateFormat(now.day, months[now.month]);\n  }\n\n  String _getWeekRange() {\n    final now = DateTime.now();\n    final weekStart = now.subtract(Duration(days: now.weekday - 1));\n    final weekEnd = weekStart.add(const Duration(days: 6));\n\n    final months = [\n      '', AppLocalizations.of(context)!.januaryShort, AppLocalizations.of(context)!.februaryShort, AppLocalizations.of(context)!.marchShort, AppLocalizations.of(context)!.aprilShort, AppLocalizations.of(context)!.mayShort, AppLocalizations.of(context)!.juneShort,\n      AppLocalizations.of(context)!.julyShort, AppLocalizations.of(context)!.augustShort, AppLocalizations.of(context)!.septemberShort, AppLocalizations.of(context)!.octoberShort, AppLocalizations.of(context)!.novemberShort, AppLocalizations.of(context)!.decemberShort\n    ];\n\n    return AppLocalizations.of(context)!.dateRangeFormat(weekStart.day, months[weekStart.month], weekEnd.day, months[weekEnd.month]);\n  }\n\n  int _getWeekNumber() {\n    final now = DateTime.now();",
      "score": 0.48530060052871704,
      "metadata": {
        "indexed_at": "2025-10-08T13:43:33.024496",
        "language": "dart",
        "file": "lib\\widgets\\stats_overview.dart",
        "chunk_index": 4,
        "type": "code"
      },
      "collection": "code"
    },
    {
      "id": "lib\\providers\\habit_provider.dart::chunk_4",
      "file": "lib\\providers\\habit_provider.dart",
      "chunk": "        final day = weekStart.add(Duration(days: i));\n        if (habit.frequency.contains(day.weekday)) {\n          scheduledDays++;\n          final dayStr = day.toDateString();\n          if (habit.completions[dayStr] ?? false) {\n            completedDays++;\n          }\n        }\n      }\n\n      return {\n        'habit': habit,\n        'completedDays': completedDays,\n        'scheduledDays': scheduledDays,\n        'percentage': scheduledDays > 0 ? (completedDays / scheduledDays * 100).toInt() : 0,\n      };\n    }).toList();\n  }\n\n  // Obtener h\u00e1bitos por completar hoy (ordenados)\n\n  List<Habit> get habitsForToday {\n    final today = DateTime.now().weekday;\n    final currentTime = TimeOfDay.now();\n\n    final habitsToday = _habits.where((habit) =>\n        habit.isActive &&\n        habit.frequency.contains(today)\n    ).toList();\n\n    // Separar completados y pendientes\n    final completed = <Habit>[];\n    final pending = <Habit>[];\n\n    for (final habit in habitsToday) {\n      if (habit.isCompletedToday) {\n        completed.add(habit);\n      } else {\n        pending.add(habit);\n      }\n    }\n\n    // Ordenar pendientes por proximidad a la hora de recordatorio\n    pending.sort((a, b) {\n      final aMinutes = a.reminderTime.hour * 60 + a.reminderTime.minute;\n      final bMinutes = b.reminderTime.hour * 60 + b.reminderTime.minute;\n      final currentMinutes = currentTime.hour * 60 + currentTime.minute;\n\n      final aDistance = (aMinutes - currentMinutes).abs();\n      final bDistance = (bMinutes - currentMinutes).abs();\n\n      return aDistance.compareTo(bDistance);\n    });\n\n    // Ordenar completados por tiempo transcurrido (m\u00e1s reciente primero)\n    // Por ahora usamos el orden por nombre como placeholder\n    // TODO: En gamificaci\u00f3n, implementar timestamps reales de completaci\u00f3n\n    completed.sort((a, b) => b.name.compareTo(a.name));\n\n    // Retornar pendientes primero, luego completados\n    return [...pending, ...completed];\n  }\n\n  // Obtener h\u00e1bitos completados hoy\n  List<Habit> get completedToday {\n    return _habits.where((h) => h.isCompletedToday).toList();\n  }\n\n  // Obtener h\u00e1bitos pendientes hoy\n  List<Habit> get pendingToday {\n    final today = DateTime.now().weekday;\n    return _habits.where((habit) => \n        habit.isActive && \n        habit.frequency.contains(today) &&\n        !habit.isCompletedToday\n    ).toList();\n  }\n\n  // M\u00e9todos auxiliares\n  void _setLoading(bool loading) {\n    _isLoading = loading;\n    notifyListeners();\n  }\n\n  void _setError(String error) {\n    _errorMessage = error;\n    notifyListeners();\n  }\n",
      "score": 0.4627041220664978,
      "metadata": {
        "file": "lib\\providers\\habit_provider.dart",
        "language": "dart",
        "chunk_index": 4,
        "indexed_at": "2025-10-08T13:43:25.068819",
        "type": "code"
      },
      "collection": "code"
    }
  ],
  "timestamp": "2025-10-08T13:43:51.272596"
}